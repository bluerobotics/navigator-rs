searchState.loadedDescShard("pwm_pca9685", 0, "This is a platform agnostic Rust driver for the PCA9685 …\nI2C device address\nAll channels\nLED all call address\nChannel 0\nChannel 1\nChannel 10\nChannel 11\nChannel 12\nChannel 13\nChannel 14\nChannel 15\nChannel 2\nChannel 3\nChannel 4\nChannel 5\nChannel 6\nChannel 7\nChannel 8\nChannel 9\nOutput channel selection\nOutput logic state is not inverted (default).\nValue set to all outputs when the output drivers are …\nAll possible errors in this crate\nSet all outputs to high-impedance.\nI²C bus error\nInvalid input data provided\nOutput logic state is inverted.\nOutputs change on ACK.\nOutputs change on STOP. (default)\nOpen-drain configuration\nOutput driver configuration\nSet all outputs to a value dependent on the <code>OutputDriver</code> …\nOutput logic state inversion\nOutput state change behavior\nPCA9685 PWM/Servo/LED controller.\nAdditional programmable address types (volatile …\nSubaddress 1\nSubaddress 2\nSubaddress 3\nTotem pole configuration (default).\nSet all outputs to 0 (default).\nDestroy driver instance, return I²C bus instance.\nDisable the controller (sleep).\nDisable responding to programmable address\nEnable the controller.\nEnable responding to programmable address\nPut the controller to sleep while keeping the PWM register …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new instance of the device.\nReset the internal state of this driver to the default …\nRe-enable the controller after a sleep with restart …\nRe-enable the controller after a sleep with restart …\nSets the address used by the driver for communication.\nSet the <code>ON</code> and <code>OFF</code> counter for each channel at once.\nSet the channel always off.\nSet the channel always on.\nSet the <code>OFF</code> counter for the selected channel.\nSet the <code>ON</code> counter for the selected channel.\nSet the <code>ON</code> and <code>OFF</code> counters for the selected channel.\nSet the output value when outputs are disabled (<code>OE</code> = 1).\nSet the output change behavior. Either byte-by-byte or all …\nSet the output driver configuration.\nSet the output logic state\nSet the prescale value.\nSet one of the programmable addresses.\nWill return an empty error for a value outside the range […\nWill return an empty error for a value outside the range […\nWill return an empty error for a value outside the range […\nEnable using the EXTCLK pin as clock source input.")